{"version":3,"file":"index.js","sources":["../../server/src/bootstrap.ts","../../server/src/destroy.ts","../../server/src/config.ts","../../server/src/constants.ts","../../server/src/document-service-middlewares/assign-sort-order-value.ts","../../server/src/register.ts","../../server/src/config/index.ts","../../server/src/content-types/index.ts","../../server/src/controllers/controller.ts","../../server/src/controllers/index.ts","../../server/src/middlewares/index.ts","../../server/src/policies/index.ts","../../server/src/routes/admin.ts","../../server/src/routes/index.ts","../../server/src/utils/reorderSubsetInPlace.ts","../../server/src/services/service.ts","../../server/src/services/index.ts","../../server/src/index.ts"],"sourcesContent":["import type { Core } from '@strapi/strapi';\n\nconst bootstrap = ({ strapi }: { strapi: Core.Strapi }) => {\n  // bootstrap phase\n};\n\nexport default bootstrap;\n","import type { Core } from '@strapi/strapi';\n\nconst destroy = ({ strapi }: { strapi: Core.Strapi }) => {\n  // destroy phase\n};\n\nexport default destroy;\n","export const config = {\n  /**\n   * The database field containing the order of the sorted entries.\n   *\n   * - Note: Unfortunatly there is no easy way to share the configuration between the admin- and server-side code,\n   *         so we need to duplicate the config here for now.\n   */\n  sortOrderField: 'sortOrder',\n} as const;\n","/**\n * Enum representing an action that is running through Strapi's Document Service middlewares.\n * https://docs.strapi.io/cms/api/document-service/middlewares#context\n *\n * This enum helps avoid using magic strings (e.g. \"create\", \"update\", \"delete\")\n * and provides a type-safe way to switch or compare against actions.\n */\nexport const enum DocumentAction {\n  Create = 'create',\n  Delete = 'delete',\n}\n","import { config } from '../config';\nimport { DocumentAction } from '../constants';\n\n//\n// Types\n//\n\nimport type { Core, Modules } from '@strapi/strapi';\nimport type { AnyDocument } from 'src/types';\n\n/** Represents the input when creating a sortable document. */\ninterface SortableDocumentInput {\n  [config.sortOrderField]: number | null;\n  [key: string]: any;\n}\n\n/** Represents a sortable document from the database. */\ninterface SortableDocument extends AnyDocument {\n  [config.sortOrderField]: number | null;\n}\n\n//\n// Helper\n//\n\nconst hasSortOrderField = (input: any): input is SortableDocumentInput =>\n  input.hasOwnProperty(config.sortOrderField);\n\n/**\n * Gets the minimum sort order value for a given content type.\n * Checks content type attributes first, then plugin config, then defaults to 1.\n *\n * @param strapi - The Strapi instance.\n * @param uid - The content type UID.\n *\n * @returns The minimum sort order value (default: 1).\n */\nconst getMinSortOrder = (strapi: Core.Strapi, uid: string): number => {\n  // First, try to get min value from content type attributes\n  try {\n    const contentType = (strapi as any).get('content-types')?.get(uid);\n    if (contentType?.attributes?.[config.sortOrderField]?.min !== undefined) {\n      const rawMinSortOrderForUid = contentType.attributes[config.sortOrderField].min;\n      if (\n        typeof rawMinSortOrderForUid === 'number' &&\n        Number.isInteger(rawMinSortOrderForUid) &&\n        rawMinSortOrderForUid >= 0\n      ) {\n        return rawMinSortOrderForUid;\n      }\n    }\n  } catch {\n    // Ignore errors when accessing content type\n  }\n\n  // Second, try to get from plugin config\n  try {\n    const rawMinSortOrder = (strapi as any).config?.get?.('plugin.sortable-entries.minSortOrder');\n    if (\n      typeof rawMinSortOrder === 'number' &&\n      Number.isInteger(rawMinSortOrder) &&\n      rawMinSortOrder >= 0\n    ) {\n      return rawMinSortOrder;\n    }\n  } catch {\n    // Ignore errors when accessing config\n  }\n\n  // Default to 1\n  return 1;\n};\n\n//\n// Middleware\n//\n\n/**\n * A middleware that automatically assigns a value to the configured sort order field when creating a new entry.\n *\n * - Note: Exporting the middleware callback directly simplifies testing. However, this export is intended solely for use in tests.\n *         For registering the middleware in the actual application, please use the default export below.\n */\nexport const assignSortOrderValueMiddlewareCallback: Modules.Documents.Middleware.Middleware =\n  async (context, next) => {\n    switch (context.action) {\n      case DocumentAction.Create:\n        const data = context.params.data;\n        if (!hasSortOrderField(data)) {\n          // The current content type does not have a sort order field, no need to auto-assign a new value.\n          break;\n        }\n\n        const sortOrder = data[config.sortOrderField];\n        if (sortOrder || sortOrder === 0) {\n          // The user has already provided a valid value for the sort order field, no need to auto-assign a new value.\n          break;\n        }\n\n        // Get the minimum sort order value\n        const minSortOrder = getMinSortOrder(strapi, context.uid);\n\n        // prettier-ignore\n        const lastEntry = (await strapi\n          .service('plugin::sortable-entries.service')\n          .fetchLastEntry({uid: context.uid, locale: data.locale})) as SortableDocument | undefined;\n\n        const lastSortOrder = lastEntry?.[config.sortOrderField];\n        let nextSortOrder: number;\n        if (lastSortOrder !== null && lastSortOrder !== undefined) {\n          nextSortOrder = lastSortOrder + 1;\n        } else {\n          nextSortOrder = minSortOrder;\n        }\n\n        data[config.sortOrderField] = nextSortOrder;\n        break;\n\n      case DocumentAction.Delete:\n        // We explicitly skip updating any sort order field(s) up-on deleting an entry,\n        // as the user would need to re-publish all above entries after deleting one.\n        break;\n\n      default:\n        break;\n    }\n\n    return await next();\n  };\n\n/**\n * Adds the above middleware to the document service.\n */\nconst assignSortOrderValueMiddleware = ({ strapi }: { strapi: Core.Strapi }) => {\n  strapi.documents.use(assignSortOrderValueMiddlewareCallback);\n};\n\nexport default assignSortOrderValueMiddleware;\n","import assignSortOrderValueMiddleware from './document-service-middlewares/assign-sort-order-value';\n\n//\n// Types\n//\n\nimport type { Core } from '@strapi/strapi';\n\n//\n// Register Phase\n//\n\nconst register = ({ strapi }: { strapi: Core.Strapi }) => {\n  assignSortOrderValueMiddleware({ strapi });\n};\n\nexport default register;\n","export default {\n  default: {},\n  validator() {},\n};\n","export default {};\n","//\n// Types\n//\n\nimport type { Core } from '@strapi/strapi';\nimport type { Context } from 'koa';\nimport type { ContentTypeUID, DocumentIDList, Filters, Locale } from 'src/types';\n\n/** The URL path parameters for the fetch entries request. */\ninterface FetchEntriesParams {\n  uid: ContentTypeUID;\n}\n\n/** The query parameters for the fetch entries request. */\ninterface FetchEntriesQuery {\n  mainField?: string;\n  filters?: Filters;\n  locale?: Locale;\n  relationFields?: string;\n}\n\n/** The URL path parameters for the update sort order request. */\ninterface UpdateSortOrderParams {\n  uid: ContentTypeUID;\n}\n\n/** The request body for the update sort order request. */\ninterface UpdateSortOrderBody {\n  data: {\n    sortedDocumentIds?: DocumentIDList;\n    filters?: Filters;\n    locale?: Locale;\n  };\n}\n\n//\n// Controller\n//\n\nconst controller = ({ strapi }: { strapi: Core.Strapi }) => ({\n  /**\n   * Controller method for the route that fetches the entries\n   * of the collection type with the given `uid` path parameter (GET request).\n   */\n  async fetchEntries(ctx: Context) {\n    try {\n      const { uid } = ctx.params as FetchEntriesParams;\n      const { mainField, filters, locale, relationFields } = ctx.request.query as FetchEntriesQuery;\n\n      if (!mainField) {\n        ctx.badRequest('Missing required `mainField` query parameter.');\n        return;\n      }\n\n      const parsedRelationFields = relationFields ? relationFields.split(',') : undefined;\n\n      const service = strapi.plugin('sortable-entries').service('service');\n      if (!service) {\n        ctx.internalServerError('Service not found');\n        return;\n      }\n\n      const entries = await service.fetchEntries({\n        uid,\n        mainField,\n        filters,\n        locale,\n        relationFields: parsedRelationFields,\n      });\n\n      // Minify response.\n      ctx.response.body = JSON.stringify(entries);\n    } catch (error) {\n      console.error('Error in fetchEntries:', error);\n      ctx.internalServerError(error instanceof Error ? error.message : 'Unknown error');\n    }\n  },\n\n  /**\n   * Controller method for the route that updates the sort order\n   * of the collection type with the given `uid` path parameter (POST request).\n   */\n  async updateSortOrder(ctx: Context) {\n    const { uid } = ctx.params as UpdateSortOrderParams;\n\n    const { data } = ctx.request.body as UpdateSortOrderBody;\n    const { sortedDocumentIds, filters, locale } = data;\n\n    if (!sortedDocumentIds) {\n      ctx.badRequest('Missing required `sortedDocumentIds` in request body.');\n      return;\n    }\n\n    const service = strapi.plugin('sortable-entries').service('service');\n    await service.updateSortOrder({\n      uid,\n      sortedDocumentIds,\n      filters,\n      locale,\n    });\n\n    // This will automatically set the `response.status` to 204 (HTTP No Content).\n    ctx.response.body = null;\n  },\n\n  /**\n   * Controller method for the route that fetches the entries (scoped mode).\n   * Scoped mode uses the same fetching behaviour as the legacy endpoint,\n   * but is wired to a dedicated route to keep the two features separated.\n   */\n  async fetchEntriesScoped(ctx: Context) {\n    return await (controller({ strapi }) as any).fetchEntries(ctx);\n  },\n\n  /**\n   * Controller method for the route that updates the sort order (scoped mode).\n   *\n   * In scoped mode we want `sortOrder` to be unique only within the active filter\n   * scope (for example per category or per relation), instead of globally across\n   * all entries of the collection type.\n   */\n  async updateSortOrderScoped(ctx: Context) {\n    const { uid } = ctx.params as UpdateSortOrderParams;\n    const { data } = ctx.request.body as UpdateSortOrderBody;\n    const { sortedDocumentIds, filters, locale } = data;\n\n    if (!sortedDocumentIds) {\n      ctx.badRequest('Missing required `sortedDocumentIds` in request body.');\n      return;\n    }\n\n    const service = strapi.plugin('sortable-entries').service('service');\n    await service.updateSortOrderScoped({\n      uid,\n      sortedDocumentIds,\n      filters,\n      locale,\n    });\n\n    ctx.response.body = null;\n  },\n});\n\nexport default controller;\n","import controller from './controller';\n\nexport default {\n  controller,\n};\n","export default {};\n","export default {};\n","export default {\n  type: 'admin',\n  routes: [\n    {\n      method: 'GET',\n      path: '/fetch-entries/:uid',\n      handler: 'controller.fetchEntries',\n      config: {\n        policies: [],\n      },\n    },\n    {\n      method: 'POST',\n      path: '/update-sort-order/:uid',\n      handler: 'controller.updateSortOrder',\n      config: {\n        policies: [],\n      },\n    },\n    {\n      method: 'GET',\n      path: '/fetch-entries-scoped/:uid',\n      handler: 'controller.fetchEntriesScoped',\n      config: {\n        policies: [],\n      },\n    },\n    {\n      method: 'POST',\n      path: '/update-sort-order-scoped/:uid',\n      handler: 'controller.updateSortOrderScoped',\n      config: {\n        policies: [],\n      },\n    },\n  ],\n};\n","import admin from './admin';\n\n// Based on:\n// https://docs.strapi.io/cms/plugins-development/server-api#routes\nconst routes = {\n  admin,\n};\n\nexport default routes;\n","/**\n * Reorders a non-contiguous subset of elements in an array to match a new specified order,\n * preserving their original positions in the array.\n *\n * @param array - The original array.\n * @param newSubsetOrder - The subset of elements (from `array`) in the desired new order.\n *\n * @returns A new array with the same structure, where the matched elements are reordered in-place.\n *\n * @throws {Error} If any element in `newSubsetOrder` is not found in `array`.\n *\n * @example\n * const array = ['a', 'b', 'c', 'd', 'e', 'f'];\n * const newSubsetOrder = ['e', 'a', 'c'];\n *\n * // 'a', 'c', and 'e' are in the original array at indices 0, 2, and 4.\n * // After reordering, the elements at those same positions become:\n * // 0 → 'e' (as it is the 1st element in `newSubsetOrder`)\n * // 2 → 'a'\n * // 4 → 'c'\n *\n * const result = reorderSubsetInPlace(array, newSubsetOrder);\n * console.log(result); // ['e', 'b', 'a', 'd', 'c', 'f']\n */\nexport const reorderSubsetInPlace = <T>(array: T[], newSubsetOrder: T[]): T[] => {\n  const subset = new Set(newSubsetOrder);\n\n  let positionsToUpdate: number[] = [];\n  array.forEach((element, index) => {\n    // For performance reasons we query the set instead of the array here,\n    // as this results in O(1) instead of O(n) lookup times.\n    if (subset.has(element)) {\n      positionsToUpdate.push(index);\n    }\n  });\n\n  if (positionsToUpdate.length !== newSubsetOrder.length) {\n    throw new Error('Some elements from the `newSubsetOrder` were not found in `array`.');\n  }\n\n  // Replace the elements in order with values from `newSubsetOrder`.\n  let mutableArray = [...array];\n  positionsToUpdate.forEach((positionToUpdate, index) => {\n    mutableArray[positionToUpdate] = newSubsetOrder[index];\n  });\n\n  return mutableArray;\n};\n","import { config } from '../config';\nimport { reorderSubsetInPlace } from '../utils/reorderSubsetInPlace';\n\n//\n// Types\n//\n\nimport type { Core } from '@strapi/strapi';\nimport type { ContentTypeUID, DocumentID, DocumentIDList, Filters, Locale } from 'src/types';\n\n//\n// Helpers\n//\n\n/**\n * Gets the minimum sort order value for a given content type.\n * Checks content type attributes first, then plugin config, then defaults to 1.\n *\n * @param strapi - The Strapi instance.\n * @param uid - The content type UID.\n *\n * @returns The minimum sort order value (default: 1).\n */\nconst getMinSortOrder = ({ strapi, uid }: { strapi: Core.Strapi; uid: ContentTypeUID }): number => {\n  // First, try to get min value from content type attributes\n  try {\n    const contentType = (strapi as any).get('content-types')?.get(uid);\n    if (contentType?.attributes?.[config.sortOrderField]?.min !== undefined) {\n      const rawMinSortOrderForUid = contentType.attributes[config.sortOrderField].min;\n      if (\n        typeof rawMinSortOrderForUid === 'number' &&\n        Number.isInteger(rawMinSortOrderForUid) &&\n        rawMinSortOrderForUid >= 0\n      ) {\n        return rawMinSortOrderForUid;\n      }\n    }\n  } catch {\n    // Ignore errors when accessing content type\n  }\n\n  // Second, try to get from plugin config\n  try {\n    const rawMinSortOrder = (strapi as any).config?.get?.('plugin.sortable-entries.minSortOrder');\n    if (\n      typeof rawMinSortOrder === 'number' &&\n      Number.isInteger(rawMinSortOrder) &&\n      rawMinSortOrder >= 0\n    ) {\n      return rawMinSortOrder;\n    }\n  } catch {\n    // Ignore errors when accessing config\n  }\n\n  // Default to 1\n  return 1;\n};\n\n//\n// Service\n//\n\nconst service = ({ strapi }: { strapi: Core.Strapi }) => ({\n  /**\n   * Retrieves all entries for a given content type, sorted by the given `sortOrderField`.\n   *\n   * @param uid - The unique identifier of the content type (e.g. 'api::products.products').\n   * @param mainField - The name of the field to display as the primary label in UI listings.\n   * @param filters - The filtering criteria to apply / `undefined` if all entries should be returned.\n   * @param locale - The current locale of the content type / `undefined` if localization is turned off.\n   *\n   * @returns A promise resolving to an array of entries,\n   *          each containing the `documentId` and the specified `mainField`.\n   */\n  async fetchEntries({\n    uid,\n    mainField,\n    filters,\n    locale,\n    relationFields,\n  }: {\n    uid: ContentTypeUID;\n    mainField: string;\n    filters: Filters | undefined;\n    locale: Locale | undefined;\n    relationFields?: string[];\n  }) {\n    // Cache contentType to avoid multiple lookups\n    let contentType: any;\n    try {\n      contentType = (strapi as any).get('content-types')?.get(uid);\n    } catch (error) {\n      throw new Error(`Content type ${uid} not found`);\n    }\n\n    const attributes = contentType?.attributes || {};\n\n    // Start with only documentId\n    // Only add mainField if it's NOT a relation field\n    const fields: string[] = ['documentId'];\n\n    // Validate mainField exists in content type and is NOT a relation field\n    if (mainField !== 'documentId' && attributes[mainField]) {\n      const attribute = attributes[mainField];\n      // Check if mainField is NOT a relation field\n      const isRelationField =\n        attribute.type === 'relation' ||\n        attribute.type === 'media' ||\n        (attribute.relation && typeof attribute.relation === 'string');\n\n      if (!isRelationField) {\n        // Only add non-relation fields to fields array\n        fields.push(mainField);\n      }\n    }\n\n    // Validate and filter relation fields to only include actual relation fields\n    const validRelationFields: string[] = [];\n    const systemFields = ['createdBy', 'updatedBy', 'localizations', 'locale'];\n\n    if (relationFields && relationFields.length > 0) {\n      relationFields.forEach((field) => {\n        // Skip system fields\n        if (systemFields.includes(field)) {\n          return;\n        }\n\n        // Check if field exists in content type AND is queryable\n        if (attributes[field]) {\n          const attribute = attributes[field];\n\n          // Only include relation or media fields that can be queried\n          // Don't add to fields array - relation fields are accessed via populate, not fields\n          if (\n            attribute.type === 'relation' ||\n            attribute.type === 'media' ||\n            (attribute.relation && typeof attribute.relation === 'string')\n          ) {\n            validRelationFields.push(field);\n            // DO NOT add relation fields to fields array - this causes \"Invalid key\" error\n            // Relation fields are accessed via populate, not fields parameter\n          }\n        }\n      });\n    }\n\n    try {\n      // Ensure fields array only contains valid, non-relation fields\n      const finalFields = fields.filter((field) => {\n        if (field === 'documentId') {\n          return true;\n        }\n        const attribute = attributes[field];\n        if (!attribute) {\n          return false;\n        }\n        const isRelationField =\n          attribute.type === 'relation' ||\n          attribute.type === 'media' ||\n          (attribute.relation && typeof attribute.relation === 'string');\n        return !isRelationField;\n      });\n\n      const result = await strapi.documents(uid).findMany({\n        fields: finalFields,\n        // Populate only validated relation fields so frontend can display relation labels\n        // Note: Strapi will automatically optimize populate queries\n        populate: validRelationFields.length > 0 ? validRelationFields : undefined,\n        sort: `${config.sortOrderField}:asc`,\n        filters,\n        locale,\n      });\n\n      return result;\n    } catch (error: any) {\n      console.error('Error fetching entries:', error?.message || error);\n      console.error('Error details:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Fetches the entry with the highest value in the configured sort order field for a given content type.\n   * This is typically used to retrieve the \"last\" entry according to the custom ordering field.\n   *\n   * @param uid - The unique identifier of the content type (e.g. 'api::products.products').\n   * @param locale - The current locale of the content type / `undefined` if localization is turned off.\n   *\n   * @returns A promise resolving to the last entry object or `null` if no entry exists.\n   */\n  async fetchLastEntry({ uid, locale }: { uid: ContentTypeUID; locale: Locale | undefined }) {\n    return await strapi.documents(uid).findFirst({\n      fields: ['documentId', config.sortOrderField],\n      sort: `${config.sortOrderField}:desc`,\n      locale,\n    });\n  },\n\n  /**\n   * Updates the sort order field of multiple entries for a given content type,\n   * based on the provided list of document IDs.\n   *\n   * @param uid - The unique identifier of the content type (e.g. 'api::products.products').\n   * @param sortedDocumentIds - An ordered array of document IDs representing the new sequence of entries.\n   * @param filters - The filtering criteria applied when fetching the entries / `undefined` if all entries were returned.\n   * @param locale - The current locale of the content type / `undefined` if localization is turned off.\n   *\n   * @returns A promise that resolves when all entries have been updated with their new sort order.\n   */\n  async updateSortOrder({\n    uid,\n    sortedDocumentIds,\n    filters,\n    locale,\n  }: {\n    uid: ContentTypeUID;\n    sortedDocumentIds: DocumentIDList;\n    filters: Filters | undefined;\n    locale: Locale | undefined;\n  }) {\n    // Fetch previous sort order of all entries to detect an actual change in position\n    // when updating the entries below and to handle any active filters.\n    // Only fetch entries that match the provided sortedDocumentIds to optimize performance\n    const prevSortedEntries = await strapi.documents(uid).findMany({\n      fields: ['documentId', config.sortOrderField],\n      sort: `${config.sortOrderField}:asc`,\n      locale,\n      // If we have filters, apply them to limit the query scope\n      ...(filters ? { filters } : {}),\n    });\n\n    // The previous sorted list of document ID's.\n    const prevSortedDocumentIds = prevSortedEntries.map((entry) => entry.documentId);\n\n    // The new sorted list of document ID's, defined by the frontend.\n    let nextSortedDocumentIds = [...sortedDocumentIds];\n\n    if (!!filters) {\n      // We have an applied filter, so the given `sortedDocumentIds` are only a subset of all entries.\n      // As the values of `sortOrderField` needs to be unique, we still need to update all entries.\n      nextSortedDocumentIds = reorderSubsetInPlace(prevSortedDocumentIds, sortedDocumentIds);\n    }\n\n    // Validate input before updating any entries.\n    // - When having no applied filter, we need to ensure the length of the given `sortedDocumentIds` matches the\n    //   length of `prevSortedDocumentIds`. Otherwise the data from the frontend is outdated.\n    // - When having an applied filter, we need to ensure `reorderSubsetInPlace()` returned all passed document ID's.\n    if (prevSortedDocumentIds.length !== nextSortedDocumentIds.length) {\n      throw new Error(`Expected to have the same number of document ID's as previously fetched.`);\n    }\n\n    // Get the minimum sort order value for this content type\n    const minSortOrder = getMinSortOrder({ strapi, uid });\n\n    // Map the new sorted list of document ID's to promises that reflect updating the corresponding database entries.\n    const updatePromises = nextSortedDocumentIds\n      .map((documentId: DocumentID, index: number) => {\n        // At this point `prevSortedDocumentIds` and `nextSortedDocumentIds` are guaranteed to have the same length.\n        // Therefore we can safely access the value at the same index.\n        const prevEntry = prevSortedEntries[index];\n\n        // Calculate the actual sort order value (index + minSortOrder)\n        const nextSortIndex = index + minSortOrder;\n\n        // To avoid unnecessary re-publishing of all entries when a new sort order is applied,\n        // we only update entries when strictly necessary. An update occurs if one of these conditions is met:\n        //\n        // 1. The entry has moved to a new position in the list.\n        //    - Example: If an entry with `documentId = \"doc-5\"` was at index 5 but now appears at index 3, its sort index must be updated.\n        //\n        // 2. The entry has never had a valid `sortOrderField` value.\n        //    - Example: A newly created entry where `sortOrderField` is `null`, `undefined` or an empty string.\n        //      → Needs an initial sort index assigned.\n        //\n        // 3. The entry's stored `sortOrderField` is outdated due to earlier changes.\n        //    - Example: If an item was at index 4 with `sortOrderField = 4`, but another entry above it was deleted, its correct index is now 3.\n        //      → Its stored value is stale and must be fixed.\n        //\n        // If none of these conditions apply we can skip the update.\n        const hasSameDocumentId = prevEntry.documentId === documentId;\n        const hasSameSortIndex = prevEntry[config.sortOrderField] === nextSortIndex;\n        if (hasSameDocumentId && hasSameSortIndex) {\n          return null;\n        }\n\n        return strapi.documents(uid).update({\n          documentId,\n          locale,\n          data: {\n            [config.sortOrderField]: nextSortIndex,\n          },\n        });\n      })\n      .filter((optionalPromise) => !!optionalPromise);\n\n    return await Promise.all(updatePromises);\n  },\n\n  /**\n   * Updates the sort order field in a scoped manner.\n   *\n   * In contrast to {@link updateSortOrder}, this method reindexes the `sortOrder`\n   * field only within the currently active filter scope (for example per category\n   * or per relation) and does not try to keep the values globally unique across\n   * the entire collection type.\n   *\n   * This allows having independent sort sequences per group, such as\n   * \"sortOrder of styles per category\" while leaving other groups untouched.\n   */\n  async updateSortOrderScoped({\n    uid,\n    sortedDocumentIds,\n    filters,\n    locale,\n  }: {\n    uid: ContentTypeUID;\n    sortedDocumentIds: DocumentIDList;\n    filters: Filters | undefined;\n    locale: Locale | undefined;\n  }) {\n    // Scoped mode requires an explicit filter to define the group.\n    // Without a filter we fall back to the legacy behaviour to avoid surprises.\n    if (!filters) {\n      return await (service as any)({ strapi }).updateSortOrder({\n        uid,\n        sortedDocumentIds,\n        filters,\n        locale,\n      });\n    }\n\n    // Fetch only entries inside the current scope (filters) and sort them by sortOrder.\n    const scopedEntries = await strapi.documents(uid).findMany({\n      fields: ['documentId', config.sortOrderField],\n      sort: `${config.sortOrderField}:asc`,\n      filters,\n      locale,\n    });\n\n    const existingDocumentIds = scopedEntries.map((entry) => entry.documentId);\n\n    // Validate that all provided ids belong to the scoped set.\n    const missingIds = sortedDocumentIds.filter(\n      (documentId) => !existingDocumentIds.includes(documentId)\n    );\n    if (missingIds.length > 0) {\n      throw new Error(\n        `Some document IDs do not belong to the current scoped filter: ${missingIds.join(', ')}`\n      );\n    }\n\n    const minSortOrder = getMinSortOrder({ strapi, uid });\n\n    const updatePromises = sortedDocumentIds.map((documentId, index) => {\n      const prevEntry = scopedEntries.find((entry) => entry.documentId === documentId);\n      const nextSortIndex = index + minSortOrder;\n\n      if (prevEntry && prevEntry[config.sortOrderField] === nextSortIndex) {\n        return null;\n      }\n\n      return strapi.documents(uid).update({\n        documentId,\n        locale,\n        data: {\n          [config.sortOrderField]: nextSortIndex,\n        },\n      });\n    });\n\n    return await Promise.all(updatePromises.filter((optionalPromise) => !!optionalPromise));\n  },\n});\n\nexport default service;\n","import service from './service';\n\nexport default {\n  service,\n};\n","/**\n * Application methods\n */\nimport bootstrap from './bootstrap';\nimport destroy from './destroy';\nimport register from './register';\n\n/**\n * Plugin server methods\n */\n\n// We explicitly need to append `/index` here to load the plugin configuration and\n// not our static configuration (which is not merged with the user configuration).\nimport config from './config/index';\nimport contentTypes from './content-types';\nimport controllers from './controllers';\nimport middlewares from './middlewares';\nimport policies from './policies';\nimport routes from './routes';\nimport services from './services';\n\nexport default {\n  register,\n  bootstrap,\n  destroy,\n  config,\n  controllers,\n  routes,\n  services,\n  contentTypes,\n  policies,\n  middlewares,\n};\n"],"names":["strapi","config","DocumentAction","getMinSortOrder","service","index"],"mappings":"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"}
{"version":3,"file":"index.mjs","sources":["../../admin/src/pluginId.ts","../../admin/src/components/Initializer/index.tsx","../../admin/src/config.ts","../../admin/src/constants.ts","../../admin/src/utils/prefixKey.ts","../../node_modules/@dnd-kit/utilities/dist/utilities.esm.js","../../node_modules/@dnd-kit/modifiers/dist/modifiers.esm.js","../../admin/src/components/SortableListItemLayout/index.tsx","../../admin/src/components/SortableListItem/index.tsx","../../admin/src/components/SortableList/index.tsx","../../admin/src/components/SortModalBody/index.tsx","../../admin/src/components/SortModal/index.tsx","../../admin/src/components/SortModalContainer/index.tsx","../../admin/src/index.ts"],"sourcesContent":["export const PLUGIN_ID = 'sortable-entries';\n","import { useEffect, useRef } from 'react';\n\nimport { PLUGIN_ID } from '../../pluginId';\n\ntype InitializerProps = {\n  setPlugin: (id: string) => void;\n};\n\nconst Initializer = ({ setPlugin }: InitializerProps) => {\n  const ref = useRef(setPlugin);\n\n  useEffect(() => {\n    ref.current(PLUGIN_ID);\n  }, []);\n\n  return null;\n};\n\nexport default Initializer;\n","export const config = {\n  /**\n   * The database field containing the order of the sorted entries.\n   *\n   * - Note: Unfortunatly there is no easy way to share the configuration between the admin- and server-side code,\n   *         so we need to duplicate the config here for now.\n   */\n  /**\n   * Default sort field name.\n   *\n   * - Used as a fallback if no matching field is found on the content type.\n   */\n  sortOrderField: 'sortOrder',\n\n  /**\n   * Candidate sort field names.\n   *\n   * - The admin UI will look for the first field in this list that exists on the\n   *   current content type and is of type \"integer\".\n   * - This allows using different field names such as \"sort\", \"order\" or \"orderIndex\".\n   */\n  sortFieldCandidates: ['sort', 'sortOrder', 'order', 'orderIndex'] as const,\n} as const;\n","/**\n * Represents the status of an asynchronous fetch operation.\n *\n * @see FetchState\n */\nexport enum FetchStatus {\n  Initial = 'initial',\n  Loading = 'loading',\n  Resolved = 'resolved',\n  Failed = 'failed',\n}\n","import { PLUGIN_ID } from '../pluginId';\n\n// This function was originally called `getTranslation(id:)` (generated by `npx @strapi/sdk-plugin init`),\n// but has been renamed to `prefixKey(key:)` because it doesn't return a translation.\nconst prefixKey = (key: string) => `${PLUGIN_ID}.${key}`;\n\nexport { prefixKey };\n","import { useMemo, useLayoutEffect, useEffect, useRef, useCallback } from 'react';\n\nfunction useCombinedRefs() {\n  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {\n    refs[_key] = arguments[_key];\n  }\n\n  return useMemo(() => node => {\n    refs.forEach(ref => ref(node));\n  }, // eslint-disable-next-line react-hooks/exhaustive-deps\n  refs);\n}\n\n// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js\nconst canUseDOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\nfunction isWindow(element) {\n  const elementString = Object.prototype.toString.call(element);\n  return elementString === '[object Window]' || // In Electron context the Window object serializes to [object global]\n  elementString === '[object global]';\n}\n\nfunction isNode(node) {\n  return 'nodeType' in node;\n}\n\nfunction getWindow(target) {\n  var _target$ownerDocument, _target$ownerDocument2;\n\n  if (!target) {\n    return window;\n  }\n\n  if (isWindow(target)) {\n    return target;\n  }\n\n  if (!isNode(target)) {\n    return window;\n  }\n\n  return (_target$ownerDocument = (_target$ownerDocument2 = target.ownerDocument) == null ? void 0 : _target$ownerDocument2.defaultView) != null ? _target$ownerDocument : window;\n}\n\nfunction isDocument(node) {\n  const {\n    Document\n  } = getWindow(node);\n  return node instanceof Document;\n}\n\nfunction isHTMLElement(node) {\n  if (isWindow(node)) {\n    return false;\n  }\n\n  return node instanceof getWindow(node).HTMLElement;\n}\n\nfunction isSVGElement(node) {\n  return node instanceof getWindow(node).SVGElement;\n}\n\nfunction getOwnerDocument(target) {\n  if (!target) {\n    return document;\n  }\n\n  if (isWindow(target)) {\n    return target.document;\n  }\n\n  if (!isNode(target)) {\n    return document;\n  }\n\n  if (isDocument(target)) {\n    return target;\n  }\n\n  if (isHTMLElement(target) || isSVGElement(target)) {\n    return target.ownerDocument;\n  }\n\n  return document;\n}\n\n/**\r\n * A hook that resolves to useEffect on the server and useLayoutEffect on the client\r\n * @param callback {function} Callback function that is invoked when the dependencies of the hook change\r\n */\n\nconst useIsomorphicLayoutEffect = canUseDOM ? useLayoutEffect : useEffect;\n\nfunction useEvent(handler) {\n  const handlerRef = useRef(handler);\n  useIsomorphicLayoutEffect(() => {\n    handlerRef.current = handler;\n  });\n  return useCallback(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return handlerRef.current == null ? void 0 : handlerRef.current(...args);\n  }, []);\n}\n\nfunction useInterval() {\n  const intervalRef = useRef(null);\n  const set = useCallback((listener, duration) => {\n    intervalRef.current = setInterval(listener, duration);\n  }, []);\n  const clear = useCallback(() => {\n    if (intervalRef.current !== null) {\n      clearInterval(intervalRef.current);\n      intervalRef.current = null;\n    }\n  }, []);\n  return [set, clear];\n}\n\nfunction useLatestValue(value, dependencies) {\n  if (dependencies === void 0) {\n    dependencies = [value];\n  }\n\n  const valueRef = useRef(value);\n  useIsomorphicLayoutEffect(() => {\n    if (valueRef.current !== value) {\n      valueRef.current = value;\n    }\n  }, dependencies);\n  return valueRef;\n}\n\nfunction useLazyMemo(callback, dependencies) {\n  const valueRef = useRef();\n  return useMemo(() => {\n    const newValue = callback(valueRef.current);\n    valueRef.current = newValue;\n    return newValue;\n  }, // eslint-disable-next-line react-hooks/exhaustive-deps\n  [...dependencies]);\n}\n\nfunction useNodeRef(onChange) {\n  const onChangeHandler = useEvent(onChange);\n  const node = useRef(null);\n  const setNodeRef = useCallback(element => {\n    if (element !== node.current) {\n      onChangeHandler == null ? void 0 : onChangeHandler(element, node.current);\n    }\n\n    node.current = element;\n  }, //eslint-disable-next-line\n  []);\n  return [node, setNodeRef];\n}\n\nfunction usePrevious(value) {\n  const ref = useRef();\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n  return ref.current;\n}\n\nlet ids = {};\nfunction useUniqueId(prefix, value) {\n  return useMemo(() => {\n    if (value) {\n      return value;\n    }\n\n    const id = ids[prefix] == null ? 0 : ids[prefix] + 1;\n    ids[prefix] = id;\n    return prefix + \"-\" + id;\n  }, [prefix, value]);\n}\n\nfunction createAdjustmentFn(modifier) {\n  return function (object) {\n    for (var _len = arguments.length, adjustments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      adjustments[_key - 1] = arguments[_key];\n    }\n\n    return adjustments.reduce((accumulator, adjustment) => {\n      const entries = Object.entries(adjustment);\n\n      for (const [key, valueAdjustment] of entries) {\n        const value = accumulator[key];\n\n        if (value != null) {\n          accumulator[key] = value + modifier * valueAdjustment;\n        }\n      }\n\n      return accumulator;\n    }, { ...object\n    });\n  };\n}\n\nconst add = /*#__PURE__*/createAdjustmentFn(1);\nconst subtract = /*#__PURE__*/createAdjustmentFn(-1);\n\nfunction hasViewportRelativeCoordinates(event) {\n  return 'clientX' in event && 'clientY' in event;\n}\n\nfunction isKeyboardEvent(event) {\n  if (!event) {\n    return false;\n  }\n\n  const {\n    KeyboardEvent\n  } = getWindow(event.target);\n  return KeyboardEvent && event instanceof KeyboardEvent;\n}\n\nfunction isTouchEvent(event) {\n  if (!event) {\n    return false;\n  }\n\n  const {\n    TouchEvent\n  } = getWindow(event.target);\n  return TouchEvent && event instanceof TouchEvent;\n}\n\n/**\r\n * Returns the normalized x and y coordinates for mouse and touch events.\r\n */\n\nfunction getEventCoordinates(event) {\n  if (isTouchEvent(event)) {\n    if (event.touches && event.touches.length) {\n      const {\n        clientX: x,\n        clientY: y\n      } = event.touches[0];\n      return {\n        x,\n        y\n      };\n    } else if (event.changedTouches && event.changedTouches.length) {\n      const {\n        clientX: x,\n        clientY: y\n      } = event.changedTouches[0];\n      return {\n        x,\n        y\n      };\n    }\n  }\n\n  if (hasViewportRelativeCoordinates(event)) {\n    return {\n      x: event.clientX,\n      y: event.clientY\n    };\n  }\n\n  return null;\n}\n\nconst CSS = /*#__PURE__*/Object.freeze({\n  Translate: {\n    toString(transform) {\n      if (!transform) {\n        return;\n      }\n\n      const {\n        x,\n        y\n      } = transform;\n      return \"translate3d(\" + (x ? Math.round(x) : 0) + \"px, \" + (y ? Math.round(y) : 0) + \"px, 0)\";\n    }\n\n  },\n  Scale: {\n    toString(transform) {\n      if (!transform) {\n        return;\n      }\n\n      const {\n        scaleX,\n        scaleY\n      } = transform;\n      return \"scaleX(\" + scaleX + \") scaleY(\" + scaleY + \")\";\n    }\n\n  },\n  Transform: {\n    toString(transform) {\n      if (!transform) {\n        return;\n      }\n\n      return [CSS.Translate.toString(transform), CSS.Scale.toString(transform)].join(' ');\n    }\n\n  },\n  Transition: {\n    toString(_ref) {\n      let {\n        property,\n        duration,\n        easing\n      } = _ref;\n      return property + \" \" + duration + \"ms \" + easing;\n    }\n\n  }\n});\n\nconst SELECTOR = 'a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not(:disabled),*[tabindex]';\nfunction findFirstFocusableNode(element) {\n  if (element.matches(SELECTOR)) {\n    return element;\n  }\n\n  return element.querySelector(SELECTOR);\n}\n\nexport { CSS, add, canUseDOM, findFirstFocusableNode, getEventCoordinates, getOwnerDocument, getWindow, hasViewportRelativeCoordinates, isDocument, isHTMLElement, isKeyboardEvent, isNode, isSVGElement, isTouchEvent, isWindow, subtract, useCombinedRefs, useEvent, useInterval, useIsomorphicLayoutEffect, useLatestValue, useLazyMemo, useNodeRef, usePrevious, useUniqueId };\n//# sourceMappingURL=utilities.esm.js.map\n","import { getEventCoordinates } from '@dnd-kit/utilities';\n\nfunction createSnapModifier(gridSize) {\n  return _ref => {\n    let {\n      transform\n    } = _ref;\n    return { ...transform,\n      x: Math.ceil(transform.x / gridSize) * gridSize,\n      y: Math.ceil(transform.y / gridSize) * gridSize\n    };\n  };\n}\n\nconst restrictToHorizontalAxis = _ref => {\n  let {\n    transform\n  } = _ref;\n  return { ...transform,\n    y: 0\n  };\n};\n\nfunction restrictToBoundingRect(transform, rect, boundingRect) {\n  const value = { ...transform\n  };\n\n  if (rect.top + transform.y <= boundingRect.top) {\n    value.y = boundingRect.top - rect.top;\n  } else if (rect.bottom + transform.y >= boundingRect.top + boundingRect.height) {\n    value.y = boundingRect.top + boundingRect.height - rect.bottom;\n  }\n\n  if (rect.left + transform.x <= boundingRect.left) {\n    value.x = boundingRect.left - rect.left;\n  } else if (rect.right + transform.x >= boundingRect.left + boundingRect.width) {\n    value.x = boundingRect.left + boundingRect.width - rect.right;\n  }\n\n  return value;\n}\n\nconst restrictToParentElement = _ref => {\n  let {\n    containerNodeRect,\n    draggingNodeRect,\n    transform\n  } = _ref;\n\n  if (!draggingNodeRect || !containerNodeRect) {\n    return transform;\n  }\n\n  return restrictToBoundingRect(transform, draggingNodeRect, containerNodeRect);\n};\n\nconst restrictToFirstScrollableAncestor = _ref => {\n  let {\n    draggingNodeRect,\n    transform,\n    scrollableAncestorRects\n  } = _ref;\n  const firstScrollableAncestorRect = scrollableAncestorRects[0];\n\n  if (!draggingNodeRect || !firstScrollableAncestorRect) {\n    return transform;\n  }\n\n  return restrictToBoundingRect(transform, draggingNodeRect, firstScrollableAncestorRect);\n};\n\nconst restrictToVerticalAxis = _ref => {\n  let {\n    transform\n  } = _ref;\n  return { ...transform,\n    x: 0\n  };\n};\n\nconst restrictToWindowEdges = _ref => {\n  let {\n    transform,\n    draggingNodeRect,\n    windowRect\n  } = _ref;\n\n  if (!draggingNodeRect || !windowRect) {\n    return transform;\n  }\n\n  return restrictToBoundingRect(transform, draggingNodeRect, windowRect);\n};\n\nconst snapCenterToCursor = _ref => {\n  let {\n    activatorEvent,\n    draggingNodeRect,\n    transform\n  } = _ref;\n\n  if (draggingNodeRect && activatorEvent) {\n    const activatorCoordinates = getEventCoordinates(activatorEvent);\n\n    if (!activatorCoordinates) {\n      return transform;\n    }\n\n    const offsetX = activatorCoordinates.x - draggingNodeRect.left;\n    const offsetY = activatorCoordinates.y - draggingNodeRect.top;\n    return { ...transform,\n      x: transform.x + offsetX - draggingNodeRect.width / 2,\n      y: transform.y + offsetY - draggingNodeRect.height / 2\n    };\n  }\n\n  return transform;\n};\n\nexport { createSnapModifier, restrictToFirstScrollableAncestor, restrictToHorizontalAxis, restrictToParentElement, restrictToVerticalAxis, restrictToWindowEdges, snapCenterToCursor };\n//# sourceMappingURL=modifiers.esm.js.map\n","import { Box, Flex } from '@strapi/design-system';\n\n/**\n * A layout wrapper component designed for use within the sortable list UI.\n * It helps to ensure sortable list items have uniform spacing and layout alignment.\n */\nconst SortableListItemLayout = ({ children }: React.PropsWithChildren) => (\n  <Box marginTop={4} marginBottom={4} marginRight={5} marginLeft={5}>\n    <Flex gap={4}>{children}</Flex>\n  </Box>\n);\n\nexport default SortableListItemLayout;\n","import { useSortable } from '@dnd-kit/sortable';\nimport { CSS } from '@dnd-kit/utilities';\n\nimport { Typography } from '@strapi/design-system';\nimport { Drag } from '@strapi/icons';\n\nimport styled from 'styled-components';\n\nimport SortableListItemLayout from '../SortableListItemLayout';\n\n//\n// Types\n//\n\nimport type { UniqueIdentifier } from '../../types';\n\n// Fixes the error \"Property `colors` does not exist on type `DefaultTheme`\" on the style below.\ninterface Theme {\n  colors: {\n    [key: string]: string | number;\n  };\n}\n\n//\n// Components\n//\n\n/**\n * A list item showing a divider at the top.\n *\n * - See also: https://github.com/strapi/design-system/blob/main/packages/design-system/src/components/Table/Table.tsx\n */\nconst DividedListItem = styled.li`\n  border-top: 1px solid ${({ theme }) => theme.colors.neutral150};\n  background: ${({ theme }) => theme.colors.neutral0};\n`;\n\n/**\n * A single item in the sortable list.\n *\n * @param id - The unique identifier of the list item.\n * @param label - The title to show in the list item.\n */\nconst SortableListItem = ({ id, label }: { id: UniqueIdentifier; label: string }) => {\n  // Based on:\n  // https://docs.dndkit.com/presets/sortable\n  const { attributes, isDragging, listeners, setNodeRef, transform, transition } = useSortable({\n    id,\n  });\n\n  // Providing a dedicated type here fixes the error \"Type `string` is not assignable to type `Position`\".\n  // https://stackoverflow.com/a/73946106\n  const style: React.CSSProperties = {\n    transform: CSS.Transform.toString(transform),\n    transition: transition,\n    // Based on:\n    // https://github.com/clauderic/dnd-kit/issues/1466\n    position: isDragging ? 'relative' : 'inherit',\n    zIndex: isDragging ? 1000 : 0,\n  };\n\n  return (\n    <DividedListItem ref={setNodeRef} style={style} {...attributes} {...listeners}>\n      <SortableListItemLayout>\n        <Drag />\n        <Typography variant=\"omega\">{label}</Typography>\n      </SortableListItemLayout>\n    </DividedListItem>\n  );\n};\n\nexport default SortableListItem;\n","import {\n  DndContext,\n  closestCenter,\n  KeyboardSensor,\n  PointerSensor,\n  useSensor,\n  useSensors,\n} from '@dnd-kit/core';\nimport { restrictToVerticalAxis } from '@dnd-kit/modifiers';\nimport {\n  SortableContext,\n  sortableKeyboardCoordinates,\n  verticalListSortingStrategy,\n} from '@dnd-kit/sortable';\n\nimport { Typography } from '@strapi/design-system';\nimport { Drag } from '@strapi/icons';\n\nimport styled from 'styled-components';\n\nimport SortableListItem from '../SortableListItem';\nimport SortableListItemLayout from '../SortableListItemLayout';\n\n//\n// Types\n//\n\nimport type { DragEndEvent as DNDKitDragEndEvent } from '@dnd-kit/core';\nimport type { DragEndEvent, SortableList } from 'src/types';\n\n// Fixes the error \"Property `colors` does not exist on type `DefaultTheme`\" on the style below.\ninterface Theme {\n  colors: {\n    [key: string]: string | number;\n  };\n}\n\n//\n// Components\n//\n\n/**\n * The bordered container for the sortable list.\n *\n * - See also: https://github.com/strapi/design-system/blob/main/packages/design-system/src/components/Table/Table.tsx\n */\nconst Container = styled.div`\n  border: 1px solid ${({ theme }) => theme.colors.neutral150};\n  border-radius: 4px;\n`;\n\nconst FadeableList = styled.ul<{ disabled: boolean }>`\n  opacity: ${({ disabled }) => (disabled ? 0.4 : 1)};\n`;\n\n/**\n * A sortable list.\n *\n * @param list - The list that should be sorted.\n * @param onDragEnd - The event handler that is called on drag end.\n * @param disabled - Boolean flag whether sorting is disabled.\n * @param heading - The heading displayed above the sortable list.\n */\nconst SortableList = ({\n  list,\n  onDragEnd,\n  disabled,\n  heading,\n}: {\n  list: SortableList;\n  onDragEnd: DragEndEvent;\n  disabled: boolean;\n  heading: string;\n}) => {\n  // Based on:\n  // https://docs.dndkit.com/presets/sortable\n  const sensors = useSensors(\n    useSensor(PointerSensor),\n    useSensor(KeyboardSensor, {\n      coordinateGetter: sortableKeyboardCoordinates,\n    })\n  );\n\n  const handleDragEnd = (event: DNDKitDragEndEvent) => {\n    const { active, over } = event;\n    if (!over) {\n      return;\n    }\n\n    if (active.id === over.id) {\n      return;\n    }\n\n    onDragEnd(active.id, over.id);\n  };\n\n  return (\n    <Container>\n      <DndContext\n        sensors={sensors}\n        collisionDetection={closestCenter}\n        modifiers={[restrictToVerticalAxis]}\n        onDragEnd={handleDragEnd}\n      >\n        <SortableContext items={list} strategy={verticalListSortingStrategy} disabled={disabled}>\n          <SortableListItemLayout>\n            <Drag fill=\"neutral600\" />\n            <Typography variant=\"sigma\" textColor=\"neutral600\">\n              {heading}\n            </Typography>\n          </SortableListItemLayout>\n          <FadeableList disabled={disabled}>\n            {list.map((listItem) => (\n              <SortableListItem key={listItem.id} id={listItem.id} label={listItem.label} />\n            ))}\n          </FadeableList>\n        </SortableContext>\n      </DndContext>\n    </Container>\n  );\n};\n\nexport default SortableList;\n","import { EmptyStateLayout, Loader } from '@strapi/design-system';\n\nimport { useIntl } from 'react-intl';\n\nimport { FetchStatus } from '../../constants';\nimport { prefixKey } from '../../utils/prefixKey';\nimport SortableListComponent from '../SortableList';\n\n//\n// Types\n//\n\nimport type { DragEndEvent, EntriesFetchState, SortableList } from 'src/types';\n\n//\n// Helpers\n//\n\n/**\n * Checks if a field is a system field (not a user-defined field).\n */\nconst isSystemField = (fieldName: string): boolean => {\n  const systemFields = [\n    'documentId',\n    'id',\n    'createdAt',\n    'updatedAt',\n    'publishedAt',\n    'createdBy',\n    'updatedBy',\n    'locale',\n    'localizations',\n  ];\n  return systemFields.includes(fieldName);\n};\n\n/**\n * Gets all relation fields from contentType attributes.\n */\nconst getRelationFields = (contentType: any): string[] => {\n  if (!contentType || !contentType.attributes) {\n    return [];\n  }\n  const relationFields: string[] = [];\n  Object.keys(contentType.attributes).forEach((fieldName) => {\n    const attribute = contentType.attributes[fieldName];\n    if (\n      attribute.type === 'relation' ||\n      attribute.type === 'media' ||\n      (attribute.type && typeof attribute.type === 'string' && attribute.type.includes('relation'))\n    ) {\n      relationFields.push(fieldName);\n    }\n  });\n  return relationFields;\n};\n\n/**\n * Gets a display label from a relation object.\n * Tries to find a meaningful field (title, name, etc.) or falls back to documentId.\n */\nconst getRelationDisplayValue = (relationItem: any): string => {\n  // Handle case where relationItem is just an ID (string or number)\n  // This happens when backend doesn't populate relation fields\n  if (typeof relationItem === 'string' || typeof relationItem === 'number') {\n    return String(relationItem);\n  }\n\n  if (typeof relationItem !== 'object' || relationItem === null) {\n    return String(relationItem);\n  }\n\n  // Try common display fields first (expanded list)\n  // Priority: key first (most common identifier), then other fields\n  const displayFields = [\n    'key', // Highest priority - most common identifier field\n    'title',\n    'name',\n    'label',\n    'slug',\n    'code',\n    'description',\n    'text',\n    'value',\n    'displayName',\n    'display_name',\n  ];\n  for (const field of displayFields) {\n    const value = relationItem[field];\n    // Only return if value is a primitive string/number, not object/array/component\n    if (\n      value !== null &&\n      value !== undefined &&\n      value !== '' &&\n      typeof value !== 'object' &&\n      !Array.isArray(value)\n    ) {\n      return String(value);\n    }\n  }\n  // Try to find any string field that might be a display field\n  // (excluding system fields, objects, arrays, and enum fields that are not good for display)\n  const excludedFields = [\n    'documentId',\n    'id',\n    'createdAt',\n    'updatedAt',\n    'publishedAt',\n    'createdBy',\n    'updatedBy',\n    'locale',\n    'localizations',\n    'displayStyle', // Exclude enum fields that are not good identifiers\n    'tag', // Exclude enum fields\n  ];\n  for (const key in relationItem) {\n    if (\n      relationItem.hasOwnProperty(key) &&\n      typeof relationItem[key] === 'string' &&\n      relationItem[key] !== '' &&\n      !excludedFields.includes(key) &&\n      // Exclude fields that look like IDs (long alphanumeric strings)\n      !/^[a-z0-9]{20,}$/i.test(relationItem[key])\n    ) {\n      return relationItem[key];\n    }\n  }\n  // Fall back to documentId or id\n  return relationItem.documentId || relationItem.id || 'Unknown';\n};\n\n/**\n * Formats the label from relation fields.\n * If multiple relation fields exist, joins them with a hyphen.\n */\nconst formatRelationLabel = (entry: any, relationFields: string[]): string => {\n  const labels: string[] = [];\n  relationFields.forEach((fieldName) => {\n    const relationValue = entry[fieldName];\n    if (relationValue) {\n      if (Array.isArray(relationValue)) {\n        const arrayLabels = relationValue\n          .map((item: any) => getRelationDisplayValue(item))\n          .filter((label: string) => label && label !== 'Unknown');\n        if (arrayLabels.length > 0) {\n          labels.push(arrayLabels.join(', '));\n        }\n      } else if (typeof relationValue === 'object' && relationValue !== null) {\n        const displayValue = getRelationDisplayValue(relationValue);\n        if (displayValue && displayValue !== 'Unknown') {\n          labels.push(displayValue);\n        }\n      } else if (relationValue !== null && relationValue !== undefined && relationValue !== '') {\n        // Handle primitive values (shouldn't happen with proper populate, but just in case)\n        labels.push(String(relationValue));\n      }\n    }\n  });\n  return labels.length > 0 ? labels.join(' - ') : '';\n};\n\n//\n// Components\n//\n\n/**\n * Gets the display value from a field, handling relation fields and system fields.\n */\nconst getFieldDisplayValue = (entry: any, fieldName: string, contentType: any): string | null => {\n  if (!fieldName || !contentType?.attributes?.[fieldName]) {\n    return null;\n  }\n\n  const attribute = contentType.attributes[fieldName];\n  const value = entry[fieldName];\n\n  // Handle relation fields\n  if (attribute.type === 'relation' || attribute.type === 'media') {\n    if (Array.isArray(value)) {\n      const labels = value\n        .map((item: any) => getRelationDisplayValue(item))\n        .filter((label: string) => label && label !== 'Unknown');\n      return labels.length > 0 ? labels.join(', ') : null;\n    } else if (value && typeof value === 'object') {\n      const displayValue = getRelationDisplayValue(value);\n      return displayValue && displayValue !== 'Unknown' ? displayValue : null;\n    }\n    return null;\n  }\n\n  // Handle regular fields\n  if (value !== null && value !== undefined && value !== '') {\n    return String(value);\n  }\n\n  return null;\n};\n\n/**\n * Returns different elements for the modal body, depending on the current fetch status.\n *\n * @param entriesFetchState - The state for fetching the entries.\n * @param mainField - The displayed field of each entry in the collection type.\n * @param additionalFields - Optional array of additional fields to display.\n * @param contentType - The content type configuration.\n * @param handleDragEnd - The event handler that is called on drag end.\n * @param disabled - Boolean flag whether sorting is disabled.\n */\nconst SortModalBody = ({\n  entriesFetchState,\n  mainField,\n  additionalFields = [],\n  contentType,\n  handleDragEnd,\n  disabled,\n}: {\n  entriesFetchState: EntriesFetchState;\n  mainField: string;\n  additionalFields?: string[];\n  contentType: any;\n  handleDragEnd: DragEndEvent;\n  disabled: boolean;\n}) => {\n  const { formatMessage } = useIntl();\n  const translate = (key: string): string => formatMessage({ id: prefixKey(key) });\n\n  switch (entriesFetchState.status) {\n    case FetchStatus.Initial:\n    case FetchStatus.Loading:\n      return <Loader />;\n\n    case FetchStatus.Failed:\n      return <EmptyStateLayout content={translate('empty-state.failure')} />;\n\n    case FetchStatus.Resolved:\n      const entries = entriesFetchState.value;\n      if (entries.length === 0) {\n        return <EmptyStateLayout content={translate('empty-state.noContent')} />;\n      }\n\n      // Check if mainField is a system field or doesn't exist in contentType attributes\n      const hasMainFieldInAttributes =\n        contentType?.attributes && mainField in contentType.attributes;\n      const isMainFieldSystem = isSystemField(mainField);\n\n      // Only use relation fields if mainField is a system field AND we have relation fields available\n      // Otherwise, try to use mainField first\n      const relationFields = getRelationFields(contentType);\n      const shouldUseRelationFields = isMainFieldSystem && relationFields.length > 0;\n\n      // Debug logging (remove in production)\n      if (process.env.NODE_ENV === 'development') {\n        console.log('[SortModalBody] Debug info:', {\n          mainField,\n          isMainFieldSystem,\n          relationFields,\n          shouldUseRelationFields,\n          firstEntry: entries[0],\n          firstEntryRelations: relationFields.reduce(\n            (acc, field) => {\n              acc[field] = entries[0]?.[field];\n              return acc;\n            },\n            {} as Record<string, any>\n          ),\n        });\n      }\n\n      // Converts the data-models into view-models for the `<SortableList />` component.\n      const sortableList: SortableList = entries.map((entry) => {\n        const labelParts: string[] = [];\n\n        // Get main field value\n        const mainFieldValue = getFieldDisplayValue(entry, mainField, contentType);\n        if (mainFieldValue) {\n          labelParts.push(mainFieldValue);\n        } else if (!isMainFieldSystem && shouldUseRelationFields && relationFields.length > 0) {\n          // Fallback to relation fields if mainField is empty\n          const relationLabel = formatRelationLabel(entry, relationFields);\n          if (relationLabel) {\n            labelParts.push(relationLabel);\n          }\n        } else if (isMainFieldSystem && shouldUseRelationFields && relationFields.length > 0) {\n          // Use relation fields if mainField is a system field\n          const relationLabel = formatRelationLabel(entry, relationFields);\n          if (relationLabel) {\n            labelParts.push(relationLabel);\n          }\n        }\n\n        // Get additional field values\n        additionalFields.forEach((fieldName) => {\n          const fieldValue = getFieldDisplayValue(entry, fieldName, contentType);\n          if (fieldValue) {\n            labelParts.push(fieldValue);\n          }\n        });\n\n        // Build final label\n        let label: string;\n        if (labelParts.length > 0) {\n          label = labelParts.join(' - ');\n        } else {\n          label = `Entry ${entry.documentId}`;\n        }\n\n        return {\n          id: entry.documentId,\n          label,\n        };\n      });\n\n      // Build heading from all fields\n      const headingParts: string[] = [mainField];\n      if (additionalFields.length > 0) {\n        headingParts.push(...additionalFields);\n      }\n      const heading = headingParts.join(' - ');\n\n      return (\n        <SortableListComponent\n          list={sortableList}\n          onDragEnd={handleDragEnd}\n          disabled={disabled}\n          heading={heading}\n        />\n      );\n  }\n};\n\nexport default SortModalBody;\n","import { arrayMove } from '@dnd-kit/sortable';\nimport { useEffect, useState, useMemo, useCallback, useRef } from 'react';\nimport { FormattedMessage, useIntl } from 'react-intl';\nimport { useSearchParams } from 'react-router-dom';\n\nimport { useFetchClient, useNotification, useQueryParams } from '@strapi/strapi/admin';\nimport {\n  Button,\n  IconButton,\n  Modal,\n  Box,\n  Typography,\n  SingleSelect,\n  SingleSelectOption,\n  TextInput,\n  Divider,\n  Flex,\n  Grid,\n} from '@strapi/design-system';\nimport { Drag } from '@strapi/icons';\n\nimport { FetchStatus } from '../../constants';\nimport { prefixKey } from '../../utils/prefixKey';\nimport SortModalBody from '../SortModalBody';\nimport { config as pluginConfig } from '../../config';\n\n//\n// Types\n//\n\nimport type { UID as StrapiUID } from '@strapi/strapi';\nimport type { Entries, DragEndEvent, EntriesFetchState, UniqueIdentifier } from 'src/types';\n\n//\n// Config\n//\n\nconst config = {\n  /** The configuration for the fetch entries request. */\n  fetchEntriesRequest: {\n    /** The path to fetch the entries of the collection type with the given `uid`. */\n    path: (uid: string) => `/sortable-entries/fetch-entries/${uid}`,\n  },\n\n  /** The configuration for the update sort order request. */\n  updateSortOrderRequest: {\n    /** The path to update the sort order of the collection type with the given `uid`. */\n    path: (uid: string) => `/sortable-entries/update-sort-order/${uid}`,\n  },\n};\n\n//\n// Components\n//\n\ntype SortMode = 'global' | 'scoped';\n\ninterface SortModalProps {\n  uid: StrapiUID.ContentType;\n  mainField: string;\n  contentType: any;\n  mode?: SortMode;\n  label?: string;\n}\n\n/**\n * A modal component that retrieves entries from the current collection type,\n * presents them in a sortable list, and enables saving changes via a submit button.\n *\n * @param uid - The unique identifier of the content type which entries are sorted.\n * @param mainField - The displayed field of each entry in the collection type.\n * @param contentType - The content type configuration.\n * @param mode - The sort mode: `\"global\"` for legacy behaviour or `\"scoped\"` for scoped sort within active filters.\n * @param label - Optional label for the trigger button (mainly used for scoped mode).\n */\nconst SortModal = ({ uid, mainField, contentType, mode = 'global', label }: SortModalProps) => {\n  const [isOpen, setIsOpen] = useState(false);\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [searchParams, setSearchParams] = useSearchParams();\n\n  const { toggleNotification } = useNotification();\n  const { formatMessage } = useIntl();\n  const translate = (key: string): string => formatMessage({ id: prefixKey(key) });\n\n  const fetchClient = useFetchClient();\n  const [entriesFetchState, setEntriesFetchState] = useState<EntriesFetchState>({\n    status: FetchStatus.Initial,\n  });\n\n  // Display field selection state\n  const [selectedDisplayField, setSelectedDisplayField] = useState<string>(mainField);\n  const [additionalDisplayField1, setAdditionalDisplayField1] = useState<string>('');\n  const [additionalDisplayField2, setAdditionalDisplayField2] = useState<string>('');\n\n  // Scoped filter selection state\n  const [selectedFilterField, setSelectedFilterField] = useState<string>('');\n  const [selectedFilterValue, setSelectedFilterValue] = useState<string>('');\n  const [filterOptions, setFilterOptions] = useState<Array<{ id: string; label: string }>>([]);\n  const [isLoadingOptions, setIsLoadingOptions] = useState(false);\n\n  /**\n   * Resolve which sort field is actually used for this content type.\n   *\n   * - We support multiple candidate field names (sort, sortOrder, order, orderIndex).\n   */\n  const resolvedSortField = useMemo(() => {\n    if (!contentType?.attributes) {\n      return pluginConfig.sortOrderField;\n    }\n\n    const attributes = contentType.attributes;\n\n    for (const candidate of pluginConfig.sortFieldCandidates) {\n      const attribute = attributes[candidate];\n      if (attribute && attribute.type === 'integer') {\n        return candidate;\n      }\n    }\n\n    const fallbackAttr = attributes[pluginConfig.sortOrderField];\n    if (fallbackAttr && fallbackAttr.type === 'integer') {\n      return pluginConfig.sortOrderField;\n    }\n\n    return pluginConfig.sortOrderField;\n  }, [contentType]);\n\n  const initialParams = { filters: undefined, plugins: { i18n: { locale: undefined } } };\n  const [queryParams, _] = useQueryParams(initialParams);\n  const listViewFilters = queryParams.query.filters;\n  const locale = queryParams.query.plugins.i18n.locale;\n\n  /**\n   * Builds a Strapi filter object from selected field and value.\n   * Supports various field types: relation, enumeration, string, number, boolean, date, etc.\n   */\n  const buildFilterFromSelection = (field: string, value: string): any => {\n    const attribute = contentType?.attributes?.[field];\n    if (!attribute) {\n      return {};\n    }\n\n    // Handle relation fields\n    if (attribute.type === 'relation') {\n      // For relation fields in Strapi v5, filter by documentId nested\n      // Format: { field: { documentId: { $in: [value] } } }\n      return {\n        [field]: {\n          documentId: {\n            $in: [value],\n          },\n        },\n      };\n    }\n\n    // Handle enumeration fields\n    if (attribute.type === 'enumeration') {\n      // For enumeration fields, use $eq for exact match\n      return {\n        [field]: {\n          $eq: value,\n        },\n      };\n    }\n\n    // Handle numeric fields (integer, biginteger, float, decimal)\n    if (['integer', 'biginteger', 'float', 'decimal'].includes(attribute.type)) {\n      const numValue = Number(value);\n      if (!isNaN(numValue)) {\n        return {\n          [field]: {\n            $eq: numValue,\n          },\n        };\n      }\n      // If not a valid number, use $contains as fallback\n      return {\n        [field]: {\n          $contains: [value],\n        },\n      };\n    }\n\n    // Handle boolean fields\n    if (attribute.type === 'boolean') {\n      const boolValue = value === 'true' || value === '1' || value === 'yes';\n      return {\n        [field]: {\n          $eq: boolValue,\n        },\n      };\n    }\n\n    // Handle date/datetime fields\n    if (['date', 'datetime', 'time', 'timestamp'].includes(attribute.type)) {\n      // For date fields, use $eq for exact match or $gte/$lte for range\n      // For now, use $eq\n      return {\n        [field]: {\n          $eq: value,\n        },\n      };\n    }\n\n    // Handle string/text fields (string, text, richtext, email, password)\n    // Use $contains for partial match\n    return {\n      [field]: {\n        $contains: [value],\n      },\n    };\n  };\n\n  // Use selected filter for scoped mode, otherwise use list view filters\n  // Use JSON.stringify to create stable reference for comparison\n  const filters = useMemo(() => {\n    if (mode === 'scoped' && selectedFilterField && selectedFilterValue) {\n      return buildFilterFromSelection(selectedFilterField, selectedFilterValue);\n    }\n    return listViewFilters;\n  }, [mode, selectedFilterField, selectedFilterValue, listViewFilters]);\n\n  // Create stable filters string for comparison\n  const filtersString = useMemo(() => JSON.stringify(filters), [filters]);\n\n  /**\n   * Fetches available options for a filterable field (relation or enumeration).\n   */\n  const fetchFilterOptions = useCallback(\n    async (fieldName: string) => {\n      if (!fieldName || !contentType?.attributes?.[fieldName]) {\n        setFilterOptions([]);\n        return;\n      }\n\n      setIsLoadingOptions(true);\n      try {\n        const attribute = contentType.attributes[fieldName];\n\n        // Handle enumeration fields\n        if (attribute.type === 'enumeration' && attribute.enum) {\n          const enumValues = Array.isArray(attribute.enum) ? attribute.enum : [];\n          const options = enumValues.map((enumValue: string) => ({\n            id: enumValue,\n            label: enumValue,\n          }));\n          setFilterOptions(options);\n          return;\n        }\n\n        // Handle relation fields\n        if (attribute.type === 'relation' && attribute.target) {\n          // Extract target UID from attribute (e.g., \"api::test-category.test-category\")\n          const targetUid = attribute.target;\n\n          // Fetch entries from the target collection using Strapi's document API\n          // Limit to 100 entries to avoid performance issues\n          // IMPORTANT: Do NOT specify sort parameter to avoid \"Invalid key name\" errors\n          // Strapi will use default sorting (usually by id or documentId)\n          const params = {\n            pageSize: 100, // Limit to 100 options to avoid lag\n            // Explicitly do NOT include sort parameter\n          };\n\n          try {\n            // First, try to get the target contentType schema to find displayable fields\n            let targetContentType: any = null;\n            try {\n              const contentTypeResponse = await fetchClient.get(\n                `/content-type-builder/content-types/${targetUid}`\n              );\n              targetContentType = contentTypeResponse?.data?.data;\n            } catch (schemaError) {\n              // If we can't get schema, continue without it\n              console.warn('Could not fetch target contentType schema:', schemaError);\n            }\n\n            // Get all entries\n            const targetEntries = await fetchClient.get(\n              `/content-manager/collection-types/${targetUid}`,\n              { params }\n            );\n\n            // Handle different response formats\n            const entries = targetEntries?.data?.results || targetEntries?.data || [];\n\n            // Find displayable fields from schema (string, text, email, etc.)\n            // Exclude component, relation, media, json, and other complex types\n            const displayableFieldNames: string[] = [];\n            const excludedTypes = ['component', 'relation', 'media', 'json', 'dynamiczone'];\n            if (targetContentType?.attributes) {\n              Object.keys(targetContentType.attributes).forEach((fieldName) => {\n                const field = targetContentType.attributes[fieldName];\n                // Include only primitive string-like fields that are good for display\n                if (\n                  ['string', 'text', 'email', 'enumeration'].includes(field.type) &&\n                  !excludedTypes.includes(field.type)\n                ) {\n                  displayableFieldNames.push(fieldName);\n                }\n                // Also include common identifier fields even if not explicitly string type\n                if (\n                  ['key', 'name', 'title', 'label', 'slug', 'code'].includes(fieldName) &&\n                  !excludedTypes.includes(field.type)\n                ) {\n                  if (!displayableFieldNames.includes(fieldName)) {\n                    displayableFieldNames.push(fieldName);\n                  }\n                }\n              });\n            }\n\n            // Common field names to try (in priority order)\n            // Priority: key first (most common identifier), then other fields\n            const commonDisplayFields = ['key', 'name', 'title', 'label', 'slug', 'code', 'value'];\n\n            // Map to options format\n            const options = entries.map((entry: any) => {\n              let displayValue: string | null = null;\n\n              // First, try fields from schema (in order)\n              for (const fieldName of displayableFieldNames) {\n                const value = entry[fieldName];\n                // Skip if value is object, array, or component\n                if (\n                  value !== null &&\n                  value !== undefined &&\n                  value !== '' &&\n                  typeof value === 'string' &&\n                  !Array.isArray(value) &&\n                  typeof value !== 'object'\n                ) {\n                  displayValue = String(value);\n                  break;\n                }\n              }\n\n              // If no value found from schema fields, try common fields (key first)\n              if (!displayValue) {\n                for (const fieldName of commonDisplayFields) {\n                  const value = entry[fieldName];\n                  // Skip if value is object, array, or component\n                  if (\n                    value !== null &&\n                    value !== undefined &&\n                    value !== '' &&\n                    typeof value === 'string' &&\n                    !Array.isArray(value) &&\n                    typeof value !== 'object'\n                  ) {\n                    displayValue = String(value);\n                    break;\n                  }\n                }\n              }\n\n              // If still no value, try to find any non-empty string field\n              // (excluding system fields, objects, arrays, and enum fields)\n              if (!displayValue) {\n                const excludedFields = [\n                  'id',\n                  'documentId',\n                  'createdAt',\n                  'updatedAt',\n                  'publishedAt',\n                  'createdBy',\n                  'updatedBy',\n                  'locale',\n                  'localizations',\n                  'displayStyle',\n                  'tag',\n                ];\n                for (const [key, value] of Object.entries(entry)) {\n                  // Skip internal and excluded fields\n                  if (excludedFields.includes(key)) {\n                    continue;\n                  }\n                  // Only accept string values, not objects or arrays\n                  if (\n                    value !== null &&\n                    value !== undefined &&\n                    value !== '' &&\n                    typeof value === 'string' &&\n                    !Array.isArray(value) &&\n                    typeof value !== 'object' &&\n                    // Exclude fields that look like IDs (long alphanumeric strings)\n                    !/^[a-z0-9]{20,}$/i.test(value)\n                  ) {\n                    displayValue = String(value);\n                    break;\n                  }\n                }\n              }\n\n              // Final fallback to documentId or id\n              if (!displayValue) {\n                displayValue = entry.documentId || String(entry.id);\n              }\n\n              return {\n                id: entry.documentId || String(entry.id),\n                label: displayValue,\n              };\n            });\n\n            setFilterOptions(options);\n            return;\n          } catch (error: any) {\n            // If request failed, log error but don't retry with sort (we never use sort)\n            console.error('Failed to fetch relation options:', error);\n            setFilterOptions([]);\n            return;\n          }\n        }\n\n        // For other field types (string, number, boolean, date, etc.), we can't fetch options\n        // User will need to type the value manually - show empty options\n        setFilterOptions([]);\n      } catch (error) {\n        console.error('Failed to fetch filter options:', error);\n        setFilterOptions([]);\n      } finally {\n        setIsLoadingOptions(false);\n      }\n    },\n    [contentType, fetchClient]\n  );\n\n  /**\n   * Checks if a field is a system field (not a user-defined field).\n   */\n  const isSystemField = (fieldName: string): boolean => {\n    const systemFields = [\n      'documentId',\n      'id',\n      'createdAt',\n      'updatedAt',\n      'publishedAt',\n      'createdBy',\n      'updatedBy',\n      'locale',\n      'localizations',\n    ];\n    return systemFields.includes(fieldName);\n  };\n\n  /**\n   * Gets all filterable fields from contentType attributes.\n   * Includes: relation, enumeration, string, number, boolean, date, email, etc.\n   * Excludes: system fields and complex types that can't be easily filtered.\n   */\n  const getFilterableFieldsMemo = useMemo(() => {\n    if (!contentType || !contentType.attributes) {\n      return [];\n    }\n    const filterableFields: string[] = [];\n    const systemFields = [\n      'documentId',\n      'id',\n      'createdAt',\n      'updatedAt',\n      'publishedAt',\n      'createdBy',\n      'updatedBy',\n      'locale',\n      'localizations',\n      'strapi_stage',\n      'strapi_assignee',\n    ];\n\n    Object.keys(contentType.attributes).forEach((fieldName) => {\n      // Skip system fields\n      if (systemFields.includes(fieldName)) {\n        return;\n      }\n\n      const attribute = contentType.attributes[fieldName];\n      if (!attribute || !attribute.type) {\n        return;\n      }\n\n      // Include all filterable field types\n      const filterableTypes = [\n        'relation',\n        'media',\n        'enumeration',\n        'string',\n        'text',\n        'richtext',\n        'email',\n        'password',\n        'integer',\n        'biginteger',\n        'float',\n        'decimal',\n        'date',\n        'time',\n        'datetime',\n        'timestamp',\n        'boolean',\n      ];\n\n      if (\n        filterableTypes.includes(attribute.type) ||\n        (attribute.type &&\n          typeof attribute.type === 'string' &&\n          attribute.type.includes('relation'))\n      ) {\n        filterableFields.push(fieldName);\n      }\n    });\n    return filterableFields;\n  }, [contentType]);\n\n  /**\n   * Gets all displayable fields from contentType attributes.\n   * Includes: string, text, email, enumeration, relation, media, number, boolean, date, etc.\n   * Excludes: system fields and the sort order field.\n   */\n  const getDisplayableFieldsMemo = useMemo(() => {\n    if (!contentType || !contentType.attributes) {\n      return [];\n    }\n    const displayableFields: string[] = [];\n    const systemFields = [\n      'documentId',\n      'id',\n      'createdAt',\n      'updatedAt',\n      'publishedAt',\n      'createdBy',\n      'updatedBy',\n      'locale',\n      'localizations',\n      'strapi_stage',\n      'strapi_assignee',\n    ];\n\n    Object.keys(contentType.attributes).forEach((fieldName) => {\n      // Skip system fields\n      if (systemFields.includes(fieldName)) {\n        return;\n      }\n\n      // Skip the sort order field\n      if (fieldName === resolvedSortField) {\n        return;\n      }\n\n      const attribute = contentType.attributes[fieldName];\n      if (!attribute || !attribute.type) {\n        return;\n      }\n\n      // Include all displayable field types\n      const displayableTypes = [\n        'string',\n        'text',\n        'richtext',\n        'email',\n        'password',\n        'enumeration',\n        'integer',\n        'biginteger',\n        'float',\n        'decimal',\n        'boolean',\n        'date',\n        'time',\n        'datetime',\n        'timestamp',\n        'relation',\n        'media',\n      ];\n\n      if (\n        displayableTypes.includes(attribute.type) ||\n        (attribute.type &&\n          typeof attribute.type === 'string' &&\n          attribute.type.includes('relation'))\n      ) {\n        displayableFields.push(fieldName);\n      }\n    });\n    return displayableFields;\n  }, [contentType, resolvedSortField]);\n\n  // Use ref to track if we're currently fetching to prevent duplicate calls\n  const isFetchingRef = useRef(false);\n  // Use ref to store abort controller for canceling requests\n  const abortControllerRef = useRef<AbortController | null>(null);\n\n  /**\n   * Fetches the entries of the current collection type.\n   */\n  const fetchEntries = useCallback(async () => {\n    // Prevent duplicate calls\n    if (isFetchingRef.current) {\n      return;\n    }\n\n    // Cancel previous request if exists\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n\n    // Create new abort controller\n    const abortController = new AbortController();\n    abortControllerRef.current = abortController;\n\n    isFetchingRef.current = true;\n    setEntriesFetchState({ status: FetchStatus.Loading });\n\n    try {\n      // Collect all display fields (main + additional)\n      const allDisplayFields = [\n        selectedDisplayField,\n        additionalDisplayField1,\n        additionalDisplayField2,\n      ].filter((field) => field && field !== '');\n\n      // Determine which relation fields should be populated on the backend.\n      // - Always include relation/media fields that are used as display fields.\n      // - If no relation display field is selected, keep the previous behaviour:\n      //   when using only system fields as display fields, fall back to all\n      //   relation fields from the content type (for backwards compatibility).\n      const relationDisplayFields: string[] = allDisplayFields.filter((fieldName) => {\n        const attr = contentType?.attributes?.[fieldName];\n        return attr?.type === 'relation' || attr?.type === 'media';\n      });\n\n      const hasSystemDisplayField = allDisplayFields.some((field) => isSystemField(field));\n\n      let relationFieldsForPopulate: string[] = [...relationDisplayFields];\n\n      if (relationFieldsForPopulate.length === 0 && hasSystemDisplayField) {\n        relationFieldsForPopulate = getFilterableFieldsMemo.filter((fieldName) => {\n          const attr = contentType?.attributes?.[fieldName];\n          return attr?.type === 'relation' || attr?.type === 'media';\n        });\n      }\n\n      const relationFieldsParam =\n        relationFieldsForPopulate.length > 0 ? relationFieldsForPopulate.join(',') : undefined;\n\n      // Collect additional fields (excluding empty and main field)\n      const additionalFieldsArray = [additionalDisplayField1, additionalDisplayField2].filter(\n        (field) => field && field !== '' && field !== selectedDisplayField\n      );\n      const additionalFieldsParam =\n        additionalFieldsArray.length > 0 ? additionalFieldsArray.join(',') : undefined;\n\n      const { data: entries } = await fetchClient.get<Entries>(\n        mode === 'scoped'\n          ? `/sortable-entries/fetch-entries-scoped/${uid}`\n          : config.fetchEntriesRequest.path(uid),\n        {\n          params: {\n            mainField: selectedDisplayField,\n            filters,\n            locale,\n            relationFields: relationFieldsParam,\n            additionalFields: additionalFieldsParam,\n          },\n          signal: abortController.signal,\n        }\n      );\n\n      // Check if request was aborted\n      if (abortController.signal.aborted) {\n        return;\n      }\n\n      setEntriesFetchState({ status: FetchStatus.Resolved, value: entries });\n    } catch (error: any) {\n      // Ignore abort errors\n      if (error?.name === 'AbortError' || abortController.signal.aborted) {\n        return;\n      }\n\n      // Only log non-abort errors\n      if (error instanceof Error && error.name !== 'AbortError') {\n        console.error(`Failed to fetch data:`, error.message);\n      }\n\n      // This will show a corresponding error message in the modal.\n      // We therefore don't need to trigger an extra notification here.\n      if (!abortController.signal.aborted) {\n        setEntriesFetchState({ status: FetchStatus.Failed });\n      }\n    } finally {\n      // Only reset if this is still the current request\n      if (abortControllerRef.current === abortController) {\n        isFetchingRef.current = false;\n        abortControllerRef.current = null;\n      }\n    }\n  }, [\n    uid,\n    selectedDisplayField,\n    additionalDisplayField1,\n    additionalDisplayField2,\n    mode,\n    filters,\n    locale,\n    getFilterableFieldsMemo,\n    contentType,\n    fetchClient,\n  ]);\n\n  // Fetch filter options when field selection changes\n  useEffect(() => {\n    if (isOpen && mode === 'scoped' && selectedFilterField) {\n      fetchFilterOptions(selectedFilterField);\n    } else {\n      setFilterOptions([]);\n    }\n  }, [selectedFilterField, isOpen, mode, fetchFilterOptions]);\n\n  // Reset selections when modal closes\n  useEffect(() => {\n    if (!isOpen) {\n      // Cancel any pending requests\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n        abortControllerRef.current = null;\n      }\n      setSelectedDisplayField(mainField);\n      setAdditionalDisplayField1('');\n      setAdditionalDisplayField2('');\n      setSelectedFilterField('');\n      setSelectedFilterValue('');\n      setFilterOptions([]);\n      // Reset refs to prevent stale state\n      isFetchingRef.current = false;\n      prevFetchParamsRef.current = '';\n    }\n  }, [isOpen, mainField]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      // Cancel any pending requests on unmount\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n        abortControllerRef.current = null;\n      }\n    };\n  }, []);\n\n  // Use ref to track previous values to prevent unnecessary fetches\n  const prevFetchParamsRef = useRef<string>('');\n\n  // Fetch the entries when modal opens or filter changes\n  useEffect(() => {\n    if (!isOpen) {\n      return;\n    }\n\n    // For scoped mode, only fetch if filter is selected\n    if (mode === 'scoped') {\n      if (!selectedFilterField || !selectedFilterValue) {\n        return;\n      }\n    }\n\n    // Create a unique key for current fetch parameters\n    const fetchKey = JSON.stringify({\n      isOpen,\n      mode,\n      selectedDisplayField,\n      additionalDisplayField1,\n      additionalDisplayField2,\n      selectedFilterField,\n      selectedFilterValue,\n      filtersString,\n      locale,\n    });\n\n    // Only fetch if parameters actually changed\n    if (prevFetchParamsRef.current === fetchKey) {\n      return;\n    }\n\n    prevFetchParamsRef.current = fetchKey;\n\n    // Increased delay to debounce rapid changes and reduce API calls\n    const timeoutId = setTimeout(() => {\n      fetchEntries();\n    }, 300);\n\n    return () => {\n      clearTimeout(timeoutId);\n    };\n  }, [\n    isOpen,\n    mode,\n    selectedDisplayField,\n    additionalDisplayField1,\n    additionalDisplayField2,\n    selectedFilterField,\n    selectedFilterValue,\n    filtersString,\n    locale,\n    fetchEntries,\n  ]);\n\n  /**\n   * The callback for the drag-end event.\n   *\n   * - See also: https://docs.dndkit.com/presets/sortable\n   */\n  const handleDragEnd: DragEndEvent = (activeID: UniqueIdentifier, overID: UniqueIdentifier) => {\n    setEntriesFetchState((entriesFetchState) => {\n      if (entriesFetchState.status !== FetchStatus.Resolved) {\n        return entriesFetchState;\n      }\n\n      const oldEntries = entriesFetchState.value;\n      const oldIndex = oldEntries.findIndex((entry) => entry.documentId === activeID);\n      const newIndex = oldEntries.findIndex((entry) => entry.documentId === overID);\n      const newEntries = arrayMove(oldEntries, oldIndex, newIndex);\n\n      return { status: FetchStatus.Resolved, value: newEntries };\n    });\n  };\n\n  /**\n   * The callback for the submit event.\n   */\n  const handleSubmit = async () => {\n    if (entriesFetchState.status !== FetchStatus.Resolved) {\n      console.error('Expect submit button to be disabled in a non `resolved` fetch state.');\n      return;\n    }\n\n    setIsSubmitting(true);\n    try {\n      // Converts the data-models into data-models for the POST request below.\n      const entries = entriesFetchState.value;\n      const sortedDocumentIds = entries.map((entry) => entry.documentId);\n\n      await fetchClient.post(\n        mode === 'scoped'\n          ? `/sortable-entries/update-sort-order-scoped/${uid}`\n          : config.updateSortOrderRequest.path(uid),\n        {\n          data: {\n            sortedDocumentIds,\n            filters,\n            locale,\n          },\n        }\n      );\n\n      setIsOpen(false);\n\n      // Workaround to refresh only the list view without reloading the entire page:\n      // Appends a timestamp-based query parameter to trigger a targeted refresh.\n      //\n      // Based on:\n      // https://stackoverflow.com/a/71466484\n      const timestamp = String(Date.now());\n      searchParams.set('t', timestamp);\n      setSearchParams(searchParams);\n    } catch (error) {\n      console.error(`Failed to submit data: ${error}`);\n\n      // We failed to submit the data.\n      // This can e.g. happen when the entries of a filtered modal are outdated.\n      toggleNotification({ type: 'danger', message: translate('notification.failure') });\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n\n  const isSubmitButtonDisabled = isSubmitting || entriesFetchState.status !== FetchStatus.Resolved;\n  const isSubmitButtonLoading = isSubmitting;\n\n  return (\n    <Modal.Root open={isOpen} onOpenChange={setIsOpen}>\n      <Modal.Trigger>\n        {mode === 'scoped' && label ? (\n          <Button variant=\"secondary\" size=\"S\">\n            {label}\n          </Button>\n        ) : (\n          <IconButton>\n            <Drag />\n          </IconButton>\n        )}\n      </Modal.Trigger>\n      <Modal.Content>\n        <Modal.Header>\n          <Modal.Title>\n            <FormattedMessage id={prefixKey('title')} />\n          </Modal.Title>\n        </Modal.Header>\n        <Modal.Body>\n          {/* Main Display Field Section */}\n          <Box paddingBottom={4}>\n            <Typography variant=\"omega\" fontWeight=\"semiBold\" as=\"label\" textColor=\"neutral800\">\n              {mode === 'scoped' ? 'View by' : 'Sort by field'}\n            </Typography>\n            <Box paddingTop={2}>\n              <SingleSelect\n                value={selectedDisplayField || mainField}\n                onChange={(value: string) => {\n                  if (value) {\n                    setSelectedDisplayField(value);\n                  }\n                }}\n                disabled={isSubmitting}\n                placeholder=\"Select a field\"\n                error={undefined}\n              >\n                <SingleSelectOption value={mainField}>{mainField} (default)</SingleSelectOption>\n                {getDisplayableFieldsMemo\n                  .filter((fieldName) => fieldName !== mainField)\n                  .map((fieldName) => {\n                    const attr = contentType?.attributes?.[fieldName];\n                    const fieldType =\n                      attr?.type === 'enumeration'\n                        ? ' (enum)'\n                        : attr?.type === 'relation'\n                          ? ' (relation)'\n                          : attr?.type === 'media'\n                            ? ' (media)'\n                            : '';\n                    return (\n                      <SingleSelectOption key={fieldName} value={fieldName}>\n                        {fieldName}\n                        {fieldType}\n                      </SingleSelectOption>\n                    );\n                  })}\n              </SingleSelect>\n            </Box>\n          </Box>\n\n          {/* Divider */}\n          <Divider />\n\n          {/* Additional Fields Section */}\n          <Box paddingTop={4} paddingBottom={4}>\n            <Typography\n              variant=\"omega\"\n              fontWeight=\"semiBold\"\n              as=\"label\"\n              textColor=\"neutral600\"\n              paddingBottom={3}\n            >\n              Additional display fields (optional)\n            </Typography>\n            <Grid.Root gap={3} columns={2}>\n              <Grid.Item col={1}>\n                <Box>\n                  <Typography variant=\"pi\" fontWeight=\"medium\" as=\"label\" textColor=\"neutral700\">\n                    Field 1\n                  </Typography>\n                  <Box paddingTop={2}>\n                    <SingleSelect\n                      value={additionalDisplayField1 || undefined}\n                      onChange={(value: string) => {\n                        setAdditionalDisplayField1(value || '');\n                      }}\n                      disabled={isSubmitting}\n                      placeholder=\"None\"\n                      clearLabel=\"Clear selection\"\n                      onClear={() => setAdditionalDisplayField1('')}\n                      error={undefined}\n                    >\n                      <SingleSelectOption value=\"\">None</SingleSelectOption>\n                      {getDisplayableFieldsMemo\n                        .filter(\n                          (fieldName) =>\n                            fieldName !== selectedDisplayField &&\n                            fieldName !== additionalDisplayField2\n                        )\n                        .map((fieldName) => {\n                          const attr = contentType?.attributes?.[fieldName];\n                          const fieldType =\n                            attr?.type === 'enumeration'\n                              ? ' (enum)'\n                              : attr?.type === 'relation'\n                                ? ' (relation)'\n                                : attr?.type === 'media'\n                                  ? ' (media)'\n                                  : '';\n                          return (\n                            <SingleSelectOption key={fieldName} value={fieldName}>\n                              {fieldName}\n                              {fieldType}\n                            </SingleSelectOption>\n                          );\n                        })}\n                    </SingleSelect>\n                  </Box>\n                </Box>\n              </Grid.Item>\n              <Grid.Item col={1}>\n                <Box>\n                  <Typography variant=\"pi\" fontWeight=\"medium\" as=\"label\" textColor=\"neutral700\">\n                    Field 2\n                  </Typography>\n                  <Box paddingTop={2}>\n                    <SingleSelect\n                      value={additionalDisplayField2 || undefined}\n                      onChange={(value: string) => {\n                        setAdditionalDisplayField2(value || '');\n                      }}\n                      disabled={isSubmitting}\n                      placeholder=\"None\"\n                      clearLabel=\"Clear selection\"\n                      onClear={() => setAdditionalDisplayField2('')}\n                      error={undefined}\n                    >\n                      <SingleSelectOption value=\"\">None</SingleSelectOption>\n                      {getDisplayableFieldsMemo\n                        .filter(\n                          (fieldName) =>\n                            fieldName !== selectedDisplayField &&\n                            fieldName !== additionalDisplayField1\n                        )\n                        .map((fieldName) => {\n                          const attr = contentType?.attributes?.[fieldName];\n                          const fieldType =\n                            attr?.type === 'enumeration'\n                              ? ' (enum)'\n                              : attr?.type === 'relation'\n                                ? ' (relation)'\n                                : attr?.type === 'media'\n                                  ? ' (media)'\n                                  : '';\n                          return (\n                            <SingleSelectOption key={fieldName} value={fieldName}>\n                              {fieldName}\n                              {fieldType}\n                            </SingleSelectOption>\n                          );\n                        })}\n                    </SingleSelect>\n                  </Box>\n                </Box>\n              </Grid.Item>\n            </Grid.Root>\n          </Box>\n          {mode === 'scoped' && (\n            <>\n              <Divider />\n              <Box paddingTop={4} paddingBottom={4}>\n                <Box paddingBottom={3}>\n                  <Typography\n                    variant=\"omega\"\n                    fontWeight=\"semiBold\"\n                    as=\"label\"\n                    textColor=\"neutral800\"\n                  >\n                    Filter by field\n                  </Typography>\n                  <Box paddingTop={2}>\n                    <SingleSelect\n                      value={selectedFilterField || undefined}\n                      onChange={(value: string) => {\n                        setSelectedFilterField(value || '');\n                        setSelectedFilterValue(''); // Reset value when field changes\n                      }}\n                      disabled={isSubmitting}\n                      placeholder=\"Select a field to filter by\"\n                      clearLabel=\"Clear selection\"\n                      onClear={() => {\n                        setSelectedFilterField('');\n                        setSelectedFilterValue('');\n                      }}\n                      error={undefined}\n                    >\n                      {getFilterableFieldsMemo.map((fieldName) => {\n                        const attr = contentType?.attributes?.[fieldName];\n                        const fieldType =\n                          attr?.type === 'enumeration'\n                            ? ' (enum)'\n                            : attr?.type === 'relation'\n                              ? ' (relation)'\n                              : '';\n                        return (\n                          <SingleSelectOption key={fieldName} value={fieldName}>\n                            {fieldName}\n                            {fieldType}\n                          </SingleSelectOption>\n                        );\n                      })}\n                    </SingleSelect>\n                  </Box>\n                </Box>\n                {selectedFilterField &&\n                  (() => {\n                    const selectedAttr = contentType?.attributes?.[selectedFilterField];\n                    const isRelationOrEnum =\n                      selectedAttr?.type === 'relation' || selectedAttr?.type === 'enumeration';\n                    const needsTextInput = !isRelationOrEnum && filterOptions.length === 0;\n\n                    return (\n                      <Box>\n                        <Typography\n                          variant=\"omega\"\n                          fontWeight=\"semiBold\"\n                          as=\"label\"\n                          textColor=\"neutral800\"\n                        >\n                          Filter value\n                        </Typography>\n                        <Box paddingTop={2}>\n                          {needsTextInput ? (\n                            // Text input for string, number, boolean, date, etc.\n                            <TextInput\n                              type={\n                                selectedAttr?.type === 'boolean'\n                                  ? 'text'\n                                  : selectedAttr?.type === 'date' ||\n                                      selectedAttr?.type === 'datetime'\n                                    ? 'date'\n                                    : ['integer', 'biginteger', 'float', 'decimal'].includes(\n                                          selectedAttr?.type || ''\n                                        )\n                                      ? 'number'\n                                      : 'text'\n                              }\n                              value={selectedFilterValue}\n                              onChange={(e: { target: { value: string } }) =>\n                                setSelectedFilterValue(e.target.value)\n                              }\n                              disabled={isSubmitting}\n                              placeholder={\n                                selectedAttr?.type === 'boolean'\n                                  ? 'Enter true/false'\n                                  : selectedAttr?.type === 'date' ||\n                                      selectedAttr?.type === 'datetime'\n                                    ? 'Select date'\n                                    : `Enter ${selectedAttr?.type || 'value'}`\n                              }\n                            />\n                          ) : (\n                            // Select dropdown for relation and enumeration\n                            <SingleSelect\n                              value={selectedFilterValue || undefined}\n                              onChange={(value: string) => setSelectedFilterValue(value || '')}\n                              disabled={\n                                isSubmitting || isLoadingOptions || filterOptions.length === 0\n                              }\n                              placeholder={\n                                isLoadingOptions ? 'Loading options...' : 'Select a value'\n                              }\n                              clearLabel=\"Clear selection\"\n                              onClear={() => setSelectedFilterValue('')}\n                              error={undefined}\n                            >\n                              {filterOptions.map((option) => (\n                                <SingleSelectOption key={option.id} value={option.id}>\n                                  {option.label}\n                                </SingleSelectOption>\n                              ))}\n                            </SingleSelect>\n                          )}\n                        </Box>\n                      </Box>\n                    );\n                  })()}\n              </Box>\n            </>\n          )}\n          {mode === 'scoped' && (!selectedFilterField || !selectedFilterValue) ? (\n            <Box padding={4}>\n              <Typography variant=\"omega\" textColor=\"neutral600\">\n                Please select a field and value to filter entries.\n              </Typography>\n            </Box>\n          ) : (\n            <SortModalBody\n              entriesFetchState={entriesFetchState}\n              mainField={selectedDisplayField}\n              additionalFields={[additionalDisplayField1, additionalDisplayField2].filter(\n                (f) => f && f !== ''\n              )}\n              contentType={contentType}\n              handleDragEnd={handleDragEnd}\n              disabled={isSubmitting}\n            />\n          )}\n        </Modal.Body>\n        <Modal.Footer>\n          <Modal.Close>\n            <Button variant=\"tertiary\">\n              <FormattedMessage id={prefixKey('cancel-button.title')} />\n            </Button>\n          </Modal.Close>\n          <Button\n            type=\"submit\"\n            onClick={handleSubmit}\n            disabled={isSubmitButtonDisabled}\n            loading={isSubmitButtonLoading}\n          >\n            <FormattedMessage id={prefixKey('submit-button.title')} />\n          </Button>\n        </Modal.Footer>\n      </Modal.Content>\n    </Modal.Root>\n  );\n};\n\nexport default SortModal;\n","// https://docs.strapi.io/dev-docs/migration/v4-to-v5/additional-resources/helper-plugin#usecmeditviewdatamanager\nimport { unstable_useContentManagerContext as useContentManagerContext } from '@strapi/strapi/admin';\n\nimport { Button } from '@strapi/design-system';\n\nimport { config } from '../../config';\nimport SortModal from '../SortModal';\n\n//\n// Components\n//\n\n/**\n * Returns the `<SortModal />` component if needed, meaning the current content type\n * supports sorting the entries and is correctly configured. Otherwise returns `null`.\n */\nconst SortModalContainer = () => {\n  const { contentType, layout } = useContentManagerContext();\n  if (!contentType) {\n    return null;\n  }\n\n  const { attributes } = contentType;\n\n  // Try to find a usable sort field on this content type.\n  // We support multiple candidate field names (sort, sortOrder, order, orderIndex).\n  const resolveSortFieldForContentType = (): string | null => {\n    if (!attributes) {\n      return null;\n    }\n\n    // Prefer any of the configured candidate fields that exist and are integers.\n    for (const candidate of config.sortFieldCandidates) {\n      const attribute = attributes[candidate];\n      if (attribute && attribute.type === 'integer') {\n        return candidate;\n      }\n    }\n\n    // Fallback to the default config field if present and valid.\n    const fallbackAttr = attributes[config.sortOrderField];\n    if (fallbackAttr && fallbackAttr.type === 'integer') {\n      return config.sortOrderField;\n    }\n\n    return null;\n  };\n\n  const sortField = resolveSortFieldForContentType();\n  if (!sortField) {\n    // Current content type does not have any supported integer sort field.\n    return null;\n  }\n\n  const { uid } = contentType;\n  const { mainField } = layout.list.settings;\n\n  return (\n    <>\n      {/* Legacy global sort modal (existing behaviour)  icon only */}\n      <SortModal uid={uid} mainField={mainField} contentType={contentType} mode=\"global\" />\n      {/* New scoped sort modal: reindexes sortOrder only within the currently active filters */}\n      <SortModal\n        uid={uid}\n        mainField={mainField}\n        contentType={contentType}\n        mode=\"scoped\"\n        label=\"Scoped sort (by filters)\"\n      />\n    </>\n  );\n};\n\nexport default SortModalContainer;\n","import { PLUGIN_ID } from './pluginId';\nimport Initializer from './components/Initializer';\nimport SortModalContainer from './components/SortModalContainer';\n\n/**\n * The view of the injection zone.\n *\n * - See also: https://docs.strapi.io/cms/plugins-development/admin-panel-api#using-predefined-injection-zones\n */\nconst enum InjectionZoneView {\n  editView = 'editView',\n  listView = 'listView',\n}\n\n/**\n * The location of the injection zone.\n *\n * - Note: We're only using `listView` and therefore only specify the corresponding locations below.\n */\nconst enum InjectionZoneLocation {\n  /** Sits between Filters and the cogs icon. */\n  actions = 'actions',\n}\n\nexport default {\n  register(app: any) {\n    app.registerPlugin({\n      id: PLUGIN_ID,\n      initializer: Initializer,\n      isReady: false,\n      name: PLUGIN_ID,\n    });\n  },\n\n  bootstrap(app: any) {\n    app\n      .getPlugin('content-manager')\n      .injectComponent(InjectionZoneView.listView, InjectionZoneLocation.actions, {\n        name: 'SortModalContainer',\n        Component: SortModalContainer,\n      });\n  },\n\n  async registerTrads({ locales }: { locales: string[] }) {\n    return Promise.all(\n      locales.map(async (locale) => {\n        try {\n          const { default: data } = await import(`./translations/${locale}.json`);\n\n          return { data, locale };\n        } catch {\n          return { data: {}, locale };\n        }\n      })\n    );\n  },\n};\n"],"names":["config","FetchStatus","SortableListComponent","pluginConfig","fieldName","isSystemField","entriesFetchState","useContentManagerContext"],"mappings":"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","x_google_ignoreList":[5,6]}